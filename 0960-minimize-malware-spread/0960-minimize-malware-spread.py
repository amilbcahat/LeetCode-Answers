class Solution:
    def __init__(self):
        self.time = 0

    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        discovery = [-1] * n  # Time of discovery of nodes
        low = [-1] * n  # Lowest point that can be reached
        parent = [-1] * n  # Parent of nodes in DFS
        inStack = [False] * n  # To check if a node is in the stack
        stack = []
        scc = []  # List to hold all SCCs

        # Tarjan's algorithm to find SCCs
        for i in range(n):
            if discovery[i] == -1:
                self.tarjanSCC(i, graph, discovery, low, parent, inStack, stack, scc)

        infectedCount = [0] * len(scc)
        componentSize = [0] * len(scc)
        componentMap = [-1] * n

        # Map nodes to their SCC and count the size of each SCC
        for i in range(len(scc)):
            for node in scc[i]:
                componentMap[node] = i
                componentSize[i] += 1

        # Count infected nodes in each SCC
        for node in initial:
            comp = componentMap[node]
            infectedCount[comp] += 1

        initial.sort()
        result = initial[0]
        maxSavedNodes = -1

        # Determine the best node to remove
        for node in initial:
            comp = componentMap[node]
            if infectedCount[comp] == 1:  # Only one malware node in this SCC
                if componentSize[comp] > maxSavedNodes:
                    maxSavedNodes = componentSize[comp]
                    result = node

        return result

    def tarjanSCC(self, u, graph, discovery, low, parent, inStack, stack, scc):
        discovery[u] = low[u] = self.time
        self.time += 1
        stack.append(u)
        inStack[u] = True

        for v in range(len(graph)):
            if graph[u][v] == 1 and u != v:  # There's an edge from u to v
                if discovery[v] == -1:  # If v is not visited
                    parent[v] = u
                    self.tarjanSCC(v, graph, discovery, low, parent, inStack, stack, scc)

                    low[u] = min(low[u], low[v])  # Update the low-link value of u
                elif inStack[v]:  # Back edge found
                    low[u] = min(low[u], discovery[v])  # Update the low-link value of u

        # If u is a root node, pop the stack and form an SCC
        if low[u] == discovery[u]:
            currentSCC = []
            while True:
                v = stack.pop()
                inStack[v] = False
                currentSCC.append(v)
                if v == u:
                    break
            scc.append(currentSCC)

